# SCUD Graph v1
# Phase: init

@meta {
  name init
  updated 2025-12-05T00:38:49.556117+00:00
}

@nodes
# id | title | status | complexity | priority
1 | Set up project scaffold with Bun, Hono, Vite, and Solid.js | P | 2 | H
2 | Define minimal system prompt and tool definitions | P | 1 | H
2.1 | Add CLAUDE.md/AGENTS.md project instructions loader | P | 0 | H
2.2 | Implement slash commands support | P | 0 | M
2.3 | Add skills loader for on-demand prompt injection | P | 0 | L
3 | Implement core agent loop with Anthropic SDK | X | 3 | H
3.1 | Set up Anthropic SDK integration | P | 0 | H
3.2 | Implement core message handling loop | P | 0 | H
3.3 | Add tool call processing and error handling | P | 0 | H
4 | Implement tool execution functions | X | 5 | H
4.1 | Implement read_file function | P | 0 | H
4.2 | Implement write_file function | P | 0 | H
4.3 | Implement edit_file function | P | 0 | H
4.4 | Implement bash function | P | 0 | H
4.5 | Add unit tests for tool functions | P | 1 | M
5 | Set up SSE endpoint for streaming events | X | 3 | H
5.1 | Define event schemas for agent events | P | 0 | H
5.2 | Implement SSE endpoint in Hono | P | 0 | H
5.3 | Integrate SSE with agent loop | P | 0 | H
6 | Build terminal-style chat UI | X | 3 | H
6.1 | Create monospace message stream with auto-scroll | P | 0 | H
6.2 | Add input bar and SSE connection | P | 0 | H
6.3 | Display tool calls as indented blocks with status | P | 0 | H
6.4 | Add syntax highlighting and visual diffs | P | 0 | M
7 | Add status bar and observability features | P | 2 | M
10 | Implement session persistence and final polish | X | 5 | M
10.1 | Define conversation data schema | P | 0 | H
10.2 | Implement save and load functions | P | 0 | H
10.3 | Integrate save/load UI and error handling | P | 0 | M
10.4 | Final polish and documentation | P | 0 | L
10.5 | Write README with architecture and AI methodology | P | 1 | H
11 | Agent execution DAG visualization (stretch) | X | 3 | L
11.1 | Define DAG Node Models and Schemas | P | 0 | H
11.2 | Implement DAG Data Collection Logic | P | 0 | H
11.3 | Create Collapsible Tree/Graph UI Visualization | P | 0 | M

@edges
# dependent -> dependency
2 -> 1
2.1 -> 2
2.2 -> 2.1
2.3 -> 2.1
3 -> 2.1
3.2 -> 3.1
3.3 -> 3.2
4 -> 3
4.5 -> 4.4
5 -> 4
5.2 -> 5.1
5.3 -> 5.2
6 -> 5
6.2 -> 6.1
6.3 -> 6.2
6.4 -> 6.3
7 -> 6
10 -> 7
10.2 -> 10.1
10.3 -> 10.2
10.4 -> 10.3
10.5 -> 10.4
11 -> 7
11.2 -> 11.1
11.3 -> 11.2

@parents
# parent: subtasks...
3: 3.1, 3.2, 3.3
4: 4.1, 4.2, 4.3, 4.4, 4.5
5: 5.1, 5.2, 5.3
6: 6.1, 6.2, 6.3, 6.4
10: 10.1, 10.2, 10.3, 10.4, 10.5
11: 11.1, 11.2, 11.3

@details
1 | description |
  Initialize a new project using Bun, set up Hono for the server, Vite for frontend build, and Solid.js with Tailwind for UI. Install dependencies (Anthropic SDK, Zod). Set up environment configuration with .env.example showing ANTHROPIC_API_KEY placeholder and clear instructions. Success: Project runs locally with a basic Hello World page and env config documented.
2 | description |
  Create a minimal system prompt (~100-150 tokens, pi-style) and define the 4 core tools (read_file, write_file, edit_file, bash) using Anthropic SDK format with Zod validation. Tools should return structured results: { output: string (for LLM), details?: object (for UI) }. Success: Tools are properly structured and can be imported without errors.
2.1 | description |
  Implement loader for project instructions from CLAUDE.md or AGENTS.md files. Check working directory for these files at session start, parse content, and append to system prompt as <project_instructions> block. This enables external task management systems (SCUD, TaskMaster, etc.) without built-in todo complexity.
2.2 | description |
  Implement slash commands: detect `/command` patterns in user input, load prompt from `.claude/commands/{command}.md` or `.agent/commands/{command}.md`, and inject as user message. Support argument substitution via $ARGUMENTS placeholder. Example: `/commit` loads commit prompt, `/review $file` passes file path.
2.3 | description |
  Add skills loader: scan `.claude/skills/*.md` or `.agent/skills/*.md` at session start, make available via `/skill:name` syntax or auto-inject based on context triggers. Skills are reusable prompt fragments for specialized tasks (e.g., code review checklist, test generation template).
3 | description |
  Build the main agent logic that handles user messages, calls the Anthropic API, and processes tool calls in a loop. Include basic error handling. Success: Agent can respond to simple text inputs without tools.
3.1 | description |
  Initialize the Anthropic client, define message schemas or structures for user inputs and API responses, and ensure basic connection to the API. This includes importing necessary libraries and setting up configuration.
3.2 | description |
  Build the main loop that receives user messages, sends them to the Anthropic API, and returns responses. Focus on simple text inputs without tools, ensuring the loop can process messages iteratively.
3.3 | description |
  Extend the loop to handle tool calls from the API responses, including invocation and result processing. Implement robust error handling: API rate limits with exponential backoff, tool execution timeouts, graceful degradation on tool failures, max iteration limits, and doom loop detection (detect when same tool called 3+ times with identical args).
4 | description |
  Create functions for each tool (read_file, write_file, edit_file, bash) with proper file I/O and command execution. Add basic validation and error handling. Success: Each tool can be executed manually and returns expected outputs.
4.1 | description |
  Create the read_file function with: line range support (offset/limit params), binary file detection with graceful handling, actionable error messages for the LLM (e.g., "file not found at /foo/bar, directory contains: [x, y, z]"), and size limits to prevent loading huge files.
4.2 | description |
  Create the write_file function with: parent directory auto-creation, permission validation before write, atomic write (write to temp then rename), and clear success/failure messages including bytes written and path confirmation.
4.3 | description |
  Create the edit_file function using robust search/replace with context matching (not naive string replace). Include: fuzzy matching for whitespace differences, line-number-based fallback, clear diff output showing before/after, and helpful errors when match not found (show similar lines).
4.4 | description |
  Create the bash function with: configurable timeout (default 30s), working directory support, streaming stdout/stderr, proper signal handling (SIGTERM/SIGKILL), output truncation for large results, and exit code reporting. Separate stdout and stderr in response.
4.5 | description |
  Write unit tests for all 4 tool functions using Bun's test runner. Cover: happy paths, error cases (file not found, permission denied, timeout), edge cases (empty files, large outputs, special characters). Aim for >80% coverage on tool functions.
5 | description |
  Configure Hono to serve an SSE endpoint that streams agent events (text_delta, tool_start, etc.) to the frontend. Integrate with the agent loop. Success: Frontend can receive real-time events from a test agent call.
5.1 | description |
  Create TypeScript interfaces for agent event types: text_delta, tool_start, tool_input_delta, tool_running, tool_result, retry_countdown, turn_complete. Tool events should include structured 'details' field for rich UI rendering (diffs, syntax-highlighted code) separate from LLM-facing 'output'.
5.2 | description |
  Configure Hono to set up an SSE endpoint that can stream events to the frontend, including proper headers and connection handling.
5.3 | description |
  Modify the agent loop to emit real-time events (text_delta, tool_start, etc.) to the SSE endpoint, and verify with a test agent call that the frontend receives them.
6 | description |
  Build a terminal-style chat UI using monospace fonts and minimal styling. Focus on clean text streaming rather than complex components. Success: Users can send messages and see agent responses + tool calls stream in real-time.
6.1 | description |
  Create a monospace message stream component with auto-scroll. Messages append like a terminal log. User messages prefixed with `>`, agent responses stream character-by-character. Keep styling minimal - dark background, light text, monospace font.
6.2 | description |
  Add input bar at bottom (terminal-style prompt) and connect to SSE endpoint. Handle send on Enter, show connection status. Parse slash commands (`/command args`) before sending.
6.3 | description |
  Display tool calls as indented blocks with status indicators: `[running]` spinner → `[done ✓]` or `[error ✗]`. Show tool name and streaming args as they arrive. Partial JSON just appends to current line.
6.4 | description |
  Add syntax highlighting for code in tool outputs (lightweight - Prism or highlight.js) and visual diffs for edit_file results using simple `- old` / `+ new` line prefixes with color. Keep it terminal-aesthetic.
7 | description |
  Add a minimal status bar showing: token count (input/output), session duration, agent status (idle/thinking/executing). Show retry countdown during rate limits. Optional: dangerous command preview before bash execution.
10 | description |
  Add functionality to save/load conversations as JSON files. Perform final error handling, styling, and write a README. Success: Sessions can be saved/reloaded, and the app is demo-ready with no obvious bugs.
10.1 | description |
  Create a JSON schema or data model to represent conversation sessions, including messages, timestamps, and metadata for saving and loading.
10.2 | description |
  Develop core logic to serialize conversations to JSON files and deserialize them back into the app state, ensuring data integrity.
10.3 | description |
  Add UI elements (e.g., buttons or menus) for saving and loading sessions, and implement error handling for file operations and invalid data.
10.4 | description |
  Apply final styling improvements, fix any remaining bugs, and perform manual testing for demo readiness. Ensure all features work end-to-end: streaming, tool calls, session save/load.
10.5 | description |
  Write comprehensive README covering: project overview, tech stack choices and rationale, architecture diagram (ASCII or mermaid), setup instructions with API key config, usage examples, and a dedicated section on AI methodology (which coding agents were used, prompting approach, iteration process). This section is explicitly required by the assessment.
11 | description |
  STRETCH GOAL: Agent execution DAG visualization. Show a collapsible tree/graph view of the agent's execution: user message → LLM call → tool calls → results → next LLM call. Each node shows: type, timing, token usage, expandable content. Useful for debugging and observability. Could be a slide-out panel or separate route.
11.1 | description |
  Create data models and schemas for DAG nodes, including fields for type (e.g., user message, LLM call, tool call), timing, token usage, and expandable content. Ensure the structure supports hierarchical relationships for the execution flow.
11.2 | description |
  Build logic to collect and structure agent execution data into a DAG format during runtime, capturing the sequence of user message → LLM call → tool calls → results → next LLM call, and populate node details with timing and token usage.
11.3 | description |
  Develop a UI component (e.g., slide-out panel or separate route) that renders the DAG as a collapsible tree or graph view, displaying node details and allowing expansion of content for debugging and observability.
